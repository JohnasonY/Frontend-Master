## cryptography: "The art/practice of writing or solving codes"

- Nowadays: Mechanisms for ensuring confidentiality, integrity, authentication (CIA), key exchange protocols, e-voting, e-auction, distinced currency (Bit-Coin).

- the study of mathemetical techniques for securing info, systems, and distributed computations against attacks
- classic crypto (B4 1980s) -> military & government, modern: everybody & everywhere

## settings of private key encryption (symmetric-key, single-key, shared-key)

Alice  -> encryption -> cipher -> open channel ->  cipher -> Decryption -> m

## Symbols of encryption

message space M (all possible messages) along with 3 algos

key space K (all possible keys)

1. Key-gen algo Gen: a probabilitic algo that outputs a key k chosen accoring to some distributions.

2. Encryption  algo Enc: takes as input a key k and a msg/plaintext m, outputs a cipher text C

   c:= Enc (k, m) = Enc.k (m)	:= determinstic

   c <- Enc (k, m)	 <-: probabilistic

3. Decryptipon algo Dec:

   m:= Dec (k, c) = Dec (c)

Correctness Requirements: 
$$
∀ m ∈ M  and  ∀ k ∈ K
$$


Dec.k (Enc.k(m)) = m holds

## Kerckhoffs' Principle:

The cipher method must not be required to be secret, and it must be able to fall into the hands of the enemy w/o inconvenience.

## 1.3 HIstorical ciphers & their cryptanalysis.

1. **Caesar's cipher**: a plaintext -> d ciphertext

   shift ciphers: k = {0,  1, ..., 25}

   |K| = 26

   Enc: letter m -> shift k positions -> letter c

   Dec: 	     <-

   

   English alphabet: {0, 1, ..., 25}

   m = m1, m2, ..., ml

   Mi ∈ {0, 1, ..., 25}

   Enc.k (m1, m2, ... , ml) = c1 c2 ... cl

   where ci = [(mi + k) mod 26]

   Dec.k (c1 c2 ... cl) = m1 m2 ... ml

   mi = [(ci - k + 26) mod 26]

   ***Key recovery attack => shift ciphers***

   Let Pi w/ 0 <= pi <= 1 be frequency of ith letter in normal English text

   calculate sum of pi^2 from 0 to 25 = 0.065

   Given some cipher text, let q.i be frequency of the ith letter of alphebat in this cipher text, # occurrences/length of cipher text if key is k, then Pi should be roughly requal to q.i+k for all i, we compute
   $$
   Ij \triangleq \sum_{i=0}^{25}Pi * q(i+j)
   $$
   for each value of j ∈ {0, 1, ... , 25}, then we expect to find that I.k = 0.065 (k is the actual key)

   I.j for j not equal to k will have much different value (smaller)

2. **substitution cipher (Monoalphabetic)**:

   Bijection:

   A => A | B | C | ... | Z

   B => A | B | C | ... | Z

   the number of keys: | K | = 26! = 2^88

   ***key recovery attack => frequency analysis***

3. **Vigehere cipher (poly-alphaletic shift cipher)**

   Kasiski's method -> keyword length

Security level: 128-bit	symmetric cipher (AES): 128-bit	asymmetric algos (RSA): 3072-bit	ECC: 256-bit
